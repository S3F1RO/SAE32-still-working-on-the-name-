#!/bin/bash


# PARAMS

# OPTS
bOpt=0;
lOpt=0;
pOpt=0;
sOpt=0;
tOpt=0;
vOpt=0;
wOpt=0;
while getopts ':blpstvw' opt; do
  case "$opt" in
    b) bOpt=1 ;;
    l) lOpt=1 ;;
    p) pOpt=1 ;;
    s) sOpt=1 ;;
    t) tOpt=1 ;;
    v) vOpt=1 ;;
    w) wOpt=1 ;;
    :) echo "Missing argument for option -$OPTARG" ;;
    \?) echo "Unexpected option -$OPTARG" ;;
  esac
done
shift $((OPTIND-1))

# ARGS
FILES=$1;
SEARCH=$2;
REPLACE=$3;

# Sudo
SUDO="";
SUDOOPT="";
if (( $sOpt == 1 )); then
  SUDO="sudo";
  SUDOOPT="-s";
fi

# Whole file search
WHOLESEARCH="";
if (( $wOpt == 1 )); then
  WHOLESEARCH="-0777";
fi



# Check script args
if (( $# == 0 )); then
  # Msg
  echo "--------------------------------------------------";
  echo "";
  echo "USAGE     : infilesreplace <files> <search> <replace>";
  echo "NOTE      : Captured expressions in <search> using (...) can be used in <replace> using \\1, \\2";
  echo "OPTIONS   : ";
  echo "            -l           : line (replace whole line)";
  echo "            -p           : paths (allow '/' in both <search> and <replace>) ('@' are forbidden)"
  echo "            -w           : whole file search instead of line search (\n is the line delimiter) (do not work with -p)";
  echo "";
  echo "            -s           : sudo";
  echo "            -t           : temporary file (preserve original file)";
  echo "            -b           : backup (keep backup of original file)"
  echo "            -v           : verbose (terminal display)";
  echo "";
  echo "EXAMPLE   : infilesreplace '*.txt' '#name#' 'Bob'";
  echo "EXAMPLE   : infilesreplace '*.txt' '^(.*);(.*);(.*)$' 'xxxxx;\2;xxxxx'";
  echo "EXAMPLE   : infilesreplace -l '*.txt' 'KEY=.*' 'KEY=VAL\n'                           Replace KEY=??? with KEY=VAL";
  echo "EXAMPLE   : infilesreplace -l '*.txt' 'KEY=.*' ''                                    Delete line KEY=???";
  echo "EXAMPLE   : infilesreplace -p '*.txt' '/home/bob/' '/home/tim/'                      Replace for paths";
  echo "EXAMPLE   : infilesreplace -w '*.txt' '<ul>([\S\s]*?)<\/ul>' '<ul><\/ul>'            Multiple line replace : delete content of <ul> tags (use not-greedy operator *?) (use [\s\S] instead of . to capture any char including \n)";
  echo "";
  echo "--------------------------------------------------";
  exit;
elif (( $# == 3 )); then
  OLDIFS=$IFS;
  IFS=$(echo -en "\\n\\b");
  for f in $FILES; do
    # Replaced file
    REPLACEDFILE="$f.rpl";

    # Backup
    if (( $bOpt == 1 )); then
      filesbackup -p $SUDOOPT "$f";
    fi

    # Line
    if (( $lOpt == 1 )); then
      SEARCH="^$SEARCH\\n$";
    fi

    # Test verbose vs real replace
    if (( $vOpt == 1 )); then
      $SUDO cat "$f" | perl -pe "s/$SEARCH/$REPLACE/g";
    else
      # Create temporary file
      ./filesrename -f -c $SUDOOPT "$f" "$REPLACEDFILE";

      # Replace in temporary file
      # Test path
      if (( $pOpt == 1 )); then
        $SUDO cat "$f" | sed -re "s@$SEARCH@$REPLACE@g" | $SUDO tee "$REPLACEDFILE" &> /dev/null;
      else
        $SUDO cat "$f" | perl $WHOLESEARCH -pe "s/$SEARCH/$REPLACE/g" | $SUDO tee "$REPLACEDFILE" &> /dev/null;
      fi

      # Override original file
      if (( $tOpt == 0 )); then
        ./filesrename -f $SUDOOPT "$REPLACEDFILE" "$f";
      fi
    fi
  done
  IFS=$OLDIFS;
fi
