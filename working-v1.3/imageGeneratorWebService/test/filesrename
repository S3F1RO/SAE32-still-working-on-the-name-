#!/bin/bash


# OPTS
cOpt=0;
dOpt=0;
fOpt=0;
sOpt=0;
vOpt=0;
CArg='';
DArg='';
ROpt=0;
SArg='';
TArg='ยง';
while getopts ':cdfsvC:D:RS:T:' opt; do
  case "$opt" in
    c) cOpt=1 ;;
    d) dOpt=1 ;;
    f) fOpt=1 ;;
    s) sOpt=1 ;;
    v) vOpt=1 ;;
    C) CArg="$OPTARG" ;;
    D) DArg="$OPTARG" ;;
    R) ROpt=1 ;;
    S) SArg="$OPTARG" ;;
    T) TArg="$OPTARG" ;;
    :) echo "Missing argument for option -$OPTARG" ;;
    \?) echo "Unexpected option -$OPTARG" ;;
  esac
done
shift $((OPTIND-1))

# ARGS
FILES=$1;
NEWFILE=$2;

# Recursive
if (( $ROpt == 1 )); then
  FILES=$(find ./ -name "$FILES");
fi

# Init counter with user value
COUNTER=1;
if [[ $CArg != "" ]]; then
  COUNTER="$CArg";
fi

# Sudo
SUDO="";
if (( $sOpt == 1 )); then
  SUDO="sudo";
fi

# Directories
DIRCOPY="";
if (( $dOpt == 1 )); then
  DIRCOPY="-R";
fi



# Check script args
if (( $# == 0 )); then
  # Msg
  echo "--------------------------------------------------";
  echo "";
  echo "USAGE     : filesrename <files> <newFiles>";
  echo "NOTE      : rename files preserving rights"
  echo "NOTE      : jokers may be used in <newFiles> field (if fifth file is '/home/bob/myFile.txt'):"
  echo "                 - '#P#' : current path '/home/bob/'";
  echo "                 - '#D#' : current dir 'bob'";
  echo "                 - '#F#' : current filename 'myFile'";
  echo "                 - '#E#' : current extension '.txt'";
  echo "                 - '#N#' : current number in enumeration '5'";
  echo "";
  echo "OPTIONS   : ";
  echo "            -R           : recursive from current dir (cannot use dir in <files> ('*':[OK], './dir/*':[FAIL]))";
  echo "            -s           : sudo";
  echo "            -v           : verbose (Perform simulation. Do not rename files)";
  echo "            -c           : copy";
  echo "            -f           : force";
  echo "            -d           : dirs instead of files";
  echo "";
  echo "            -C <nb>      : add counter counting from nb"
  echo "            -D <nbDigit> : digits for counter"
  echo "";
  echo "            -S <search>  : search pattern (perl regex allowed, including ^, $ and (.*))"
  echo "                           search pattern applies in filename only (path and extension are not affected)"
  echo "            -T <replTo>  : replace to pattern (\1, \2, \3 and \U, \L allowed)"
  echo "";
  echo -e "EXAMPLE   : filesrename 'path/*' '#P##F##E#'                         Keep the same path, filename and extension (nothing done)";
  echo -e "EXAMPLE   : filesrename 'path/*' 'newpath/#F##E#'                    Move";
  echo -e "EXAMPLE   : filesrename '*' '#F#.cfg'                                Change extension (aaa.txt --> aaa.cfg, bbb --> bbb.cfg)";
  echo -e "EXAMPLE   : filesrename '*' 'my_#F#_backup#E#'                       Rename with prefix and postfix (aaa.txt --> my_aaa_backup.txt)";
  echo -e "EXAMPLE   : filesrename '*' 'file#N##E#'                           	Rename using counter (aaa.txt --> file1.txt, bbb --> file2) [CAUTION : changing filename without using counter could lead to file loss]";
  echo -e "EXAMPLE   : filesrename -C 10 -D 3 '*' 'file#N##E#'                  Rename using counter with digits (aaa.txt --> file010.txt, bbb --> file011)";
  echo -e "EXAMPLE   : filesrename -R '*' '#P##F##E#.tmp'                       Rename recursively (path1/aaa.txt --> path1/aaa.txt.tmp, path2/bbb --> path2/bbb.tmp)";
  echo -e "EXAMPLE   : filesrename -R '*' '#D#_#F##E#'                          Move recursively all files to current directory, prefixing their name using their original directory (??/dir1/aaa.txt --> dir1_aaa.txt, ??/??/??/dir2/bbb --> dir2_bbb)";
  echo -e "EXAMPLE   : filesrename -v '*.txt' '#F#.cfg'                         Simulate renaming (nothing changed)";
  echo -e "EXAMPLE   : filesrename -Rd '*bob*' 'MyDir#N#'                       Move recursively all directories containing 'bob' into current directory with names (MyDir1, MyDir2, MyDir3)";
  echo -e "EXAMPLE   : filesrename -Rcd '*' '#P##F#.back'                       Recursively create a backup copy of all directories (dir1/dir2 --> dir1/dir2.back)";
  echo -e "EXAMPLE   : filesrename -S '^(.*)-(.*)$' -T '\U\2-\1' '*' '#P##F##E#'Invert the two parts of the filename using upper case (bob-marley.txt --> MARLEY-bob.txt)";
  echo "";
  echo "--------------------------------------------------";
  exit;
elif (( $# == 2 )); then

  # Rename files
  IFSOld=$IFS;
  IFS=$'\n';
  for f in $FILES; do
    # Check file / directory
    if ( [ -f "$f" ] && (( $dOpt == 0 )) ) || ( [ -d "$f" ] && (( $dOpt == 1 )) ); then
      # Extract dir
      FILEPATH=$(echo "$f" | perl -pe "s/^(.*?)([^\.\/]*)([^\/]*)$/\1/g");
      FILENAME=$(echo "$f" | perl -pe "s/^(.*?)([^\.\/]*)([^\/]*)$/\2/g");
      FILEEXT=$(echo "$f" | perl -pe "s/^(.*?)([^\.\/]*)([^\/]*)$/\3/g");
      FILEDIR=$(echo "$FILEPATH" | perl -pe "s/^(.*?\/)?([^\/]*\/)?$/\2/g");
      FILEDIR=$(echo "$FILEDIR" | perl -pe "s/^(.*)\/$/\1/g" | perl -pe "s/\.//g");
      FILEPATHPARENT=$(echo "$FILEPATH" | perl -pe "s/^(.*?\/)?([^\/]*\/)?$/\1/g");
      if [[ $FILEPATH == "./" ]]; then
        FILEPATH="";
      fi

      # Update counter display
      COUNTERDISPLAY="$COUNTER";
      if [[ $DArg != "" ]]; then
        COUNTERDISPLAY=$(printf "%0${DArg}d" "$COUNTER");
      fi

      # Update counter
      COUNTER=$(($COUNTER+1));

      # If search-replace pattern
      if [[ $SArg != "" ]] && [[ $TArg != "ยง" ]]; then
        # Search and replace pattern
        FILENAME=$(echo "$FILENAME" | sed -re "s@$SArg@$TArg@g");
      fi

      # Replace #P# by current path, #D# by current dir, #F# by current filename, #E# by current extension, #N# by current number
      DEST=$(echo "$NEWFILE" | sed -re "s@#P#@$FILEPATH@g"  | sed -re "s@#D#@$FILEDIR@g" | sed -re "s@#F#@$FILENAME@g" | sed -re "s@#E#@$FILEEXT@g" | sed -re "s@#N#@$COUNTERDISPLAY@g");

      # Test destination does not exist
      if [ ! -e "$DEST" ] || (( $fOpt == 1 )); then
        # Test copy vs move
        if (( $cOpt == 1 )); then
          # Test simulation vs real
          if (( $vOpt == 1 )); then
            echo -e "\t[CMD]> $SUDO cp -R --preserve=all $DIRCOPY '$f' '$DEST'";
          else
            $SUDO cp -R --preserve=all $DIRCOPY "$f" "$DEST";
          fi
        else
          # Test simulation vs real
          if (( $vOpt == 1 )); then
            echo -e "\t[CMD]> $SUDO mv '$f' '$DEST'";
          else
            $SUDO mv "$f" "$DEST";
          fi
        fi
      else
        echo -e "[FAIL] Destination '$DEST' already exists ('$f' skipped)";
      fi
    fi
  done
  IFS=$IFSOld;
else
  echo -e "[WARN] Commands such as   > filesrename *.txt   must be replaced by   > filesrename '*.txt'";
fi
